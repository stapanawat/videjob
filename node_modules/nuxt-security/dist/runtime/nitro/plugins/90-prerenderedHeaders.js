import { defineNitroPlugin, useStorage } from "nitropack/runtime";
import { getResponseHeaders, setResponseHeaders } from "h3";
import { resolveSecurityRules } from "../context/index.js";
export default defineNitroPlugin(async (nitroApp) => {
  if (import.meta.prerender) {
    const prerenderedHeaders = {};
    nitroApp.hooks.hook("render:html", (_, { event }) => {
      const rules = resolveSecurityRules(event);
      if (rules.enabled && rules.ssg && rules.ssg.nitroHeaders) {
        const headers = getResponseHeaders(event);
        const path = event.path.split("?")[0];
        if (!path) return;
        prerenderedHeaders[path] = headers;
      }
    });
    nitroApp.hooks.hook("close", async () => {
      const headers = Object.fromEntries(
        Object.entries(prerenderedHeaders).map(([path, headers2]) => {
          const headersEntries = Object.entries(headers2).filter(([header]) => header !== "x-nitro-prerender").map(([header, value]) => {
            if (Array.isArray(value)) {
              return [header, value.join(";")];
            } else {
              return [header, value];
            }
          });
          return [path, Object.fromEntries(headersEntries)];
        })
      );
      await useStorage("build:nuxt-security").setItem("headers.json", headers);
    });
  } else {
    const prerenderedHeaders = await useStorage("assets:nuxt-security").getItem("headers.json") || {};
    nitroApp.hooks.hook("beforeResponse", (event) => {
      const rules = resolveSecurityRules(event);
      if (rules.enabled && rules.ssg && rules.ssg.nitroHeaders) {
        const path = event.path.split("?")[0];
        if (path && prerenderedHeaders[path]) {
          setResponseHeaders(event, prerenderedHeaders[path]);
        }
      }
    });
  }
});
